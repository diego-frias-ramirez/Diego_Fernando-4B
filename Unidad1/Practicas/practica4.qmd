---
title: "Práctica 4 - Herencia"
subtitle: "Gestión de Tickets con Empleados"
author: "Diego Fernando Frías Ramírez"
date: today
format: 
  html: default
  pdf:
    documentclass: article
    geometry: 
      - top=1.2in
      - bottom=1.2in
      - left=1in
      - right=1in
    fontsize: 12pt
    mainfont: "Times New Roman"
    colorlinks: true
    linkcolor: blue
    urlcolor: blue
    toc: true
    toc-depth: 2
    number-sections: true
    highlight-style: github
    code-block-bg: "#f8f9fa"
    code-block-border-left: "#007acc"
    fig-cap-location: bottom
    tbl-cap-location: top
    header-includes: |
      \usepackage{fancyhdr}
      \pagestyle{fancy}
      \fancyhead[L]{Práctica 4 - Herencia}
      \fancyhead[R]{Diego Fernando}
      \fancyfoot[C]{\thepage}
execute:
  echo: true
  eval: false
  warning: false
  message: false
jupyter: python3
---

## Introducción

En esta práctica trabajaremos el concepto de **herencia en Programación Orientada a Objetos**.  
La herencia permite que una clase hija adquiera atributos y métodos de una clase padre, pudiendo extender o modificar su funcionalidad.  

Se implementa un sistema de **gestión de tickets**, donde distintos tipos de empleados (Desarrollador, Tester y Project Manager) tienen funciones específicas para resolver tickets.  
Además, se construye un **menú interactivo en consola** para manipular tickets.

---

## Clase Ticket

Creamos la clase `Ticket` con atributos básicos como id, tipo, prioridad y estado.

```{python}
class Ticket:
    def __init__(self, id, tipo, prioridad, estado = "pendiente"):
        self.id = id
        self.tipo = tipo
        self.prioridad = prioridad
        self.estado = "pendiente"

    def __str__(self):
        return f"{self.id:<15}{self.tipo:<10}{self.prioridad:<10}{self.estado:<10}"
```

**¿Qué hace este código?**  
Define un ticket con sus características y sobreescribe el método `__str__()` para imprimirlo en un formato tabular.

## Clase Padre: Empleado

Creamos una clase padre llamada `Empleado`, de la cual heredarán otras clases.

```{python}
class Empleado:
    def __init__(self, nombre):
        self.nombre = nombre

    def trabajar_ticket(self, ticket):
        print(f"El empleado {self.nombre} revisa el ticket {ticket.id}")
```

**¿Qué hace este código?**  
La clase `Empleado` almacena el nombre y un método genérico para trabajar con tickets.

## Clases Hijas: Desarrollador y Tester

Creamos dos clases hijas que heredan de `Empleado` y redefinen el método `trabajar_ticket`.

```{python}
class Desarrollador(Empleado):
    def trabajar_ticket(self, ticket):
        if ticket.tipo.lower() == "software":
            ticket.estado = "resuelto"
            print(f"El ticket {ticket.id} fue resuelto por {self.nombre}")
        else:
            print(f"{self.nombre} no puede resolver tickets de tipo '{ticket.tipo}'")

class Tester(Empleado):
    def trabajar_ticket(self, ticket):
        if ticket.tipo.lower() == "prueba":
            ticket.estado = "resuelto"
            print(f"El ticket {ticket.id} fue resuelto por {self.nombre}")
        else:
            print(f"{self.nombre} no puede resolver tickets de tipo '{ticket.tipo}'")
```

**¿Qué hace este código?**

- El `Desarrollador` solo resuelve tickets de tipo software.
- El `Tester` solo resuelve tickets de tipo prueba.

## Clase Project Manager

El Project Manager también hereda de `Empleado`, pero su rol es asignar tickets a otros empleados.

```{python}
class ProjectManager(Empleado):
    def asignar_ticket(self, ticket, empleado):
        print(f"{self.nombre} asignó el ticket {ticket.id} al empleado {empleado.nombre}")
        empleado.trabajar_ticket(ticket)

developer1 = Desarrollador("Gustavo")
tester1 = Tester("Pablo")
pm = ProjectManager("Susana")
```

## Funciones de Gestión de Tickets

Implementamos funciones para crear, ver y asignar tickets.

```
tickets = []

def crearTicket():
    print("\n\t\t.::Agregar ticket::.\n\t")
    id = input("\nIngresa el id: ").upper().strip()
    tipo = input("\nIngresa el tipo: ").upper().strip()
    prioridad = input("\nIngresa la prioridad: ").upper().strip()
    estado = input("\nIngresa el estado: ").upper().strip()
    new_ticket = Ticket(id, tipo, prioridad, estado)
    tickets.append(new_ticket)
    print("\n\t:::¡LA OPERACIÓN SE REALIZÓ CON ÉXITO!\n\t")

def verTicket():
    print("Mostrar Ticket")
    if len(tickets) > 0:
        print(f"{'id':<15}{'tipo':<10}{'prioridad':<10}{'estado':<10}")
        print("-" * 50)
        for ticket in tickets:
            print(ticket)
        print("-" * 50)
    else:
        print("No hay Tickets en el sistema")

def asignar_ticket(ticket_id, empleado_nombre, pm, developer1, tester1):
    ticket = next((t for t in tickets if t.id == ticket_id), None)
    if ticket:
        if empleado_nombre == developer1.nombre:
            pm.asignar_ticket(ticket, developer1)
        elif empleado_nombre == tester1.nombre:
            pm.asignar_ticket(ticket, tester1)
        else:
            print("Empleado no encontrado.")
    else:
        print("Ticket no encontrado.")
```

## Menú Principal

Finalmente, un menú en consola que permite crear, ver y asignar tickets.

```
def borrarPantalla():
    import os
    os.system("cls")

def esperarTecla():
    input("Oprima cualquier tecla para continuar")

developer1 = Desarrollador("Gustavo")
tester1 = Tester("Pablo")
pm = ProjectManager("Susana")

opcion = True
while opcion:
    borrarPantalla()
    print("\n\t\t\t..::: Tickets :::... \n\t\t..::: Sistema de Gestión de Tickets :::...\n\t\t 1.- Crear ticket  \n\t\t 2.- Ver tickets \n\t\t 3.- Asignar tickets \n\t\t 4.- SALIR ")
    opcion = input("\t Elige una opción: ").upper()

    match opcion:
        case "1":
            crearTicket()
            esperarTecla()
            borrarPantalla()
        case "2":
            verTicket()
            esperarTecla()
            borrarPantalla()
        case "3":
            ticket_id = input("\nIngresa el ID del ticket a asignar: ").strip().upper()
            empleado_nombre = input("Ingresa el nombre del empleado: ").strip().capitalize()
            asignar_ticket(ticket_id, empleado_nombre, pm, developer1, tester1)  
            esperarTecla()
            borrarPantalla()
        case "4":
            opcion = False    
            print("\n\t\t Terminaste la ejecución del sistema.")
        case _:
            print("Opción inválida, vuelve a intentarlo... Presiona Enter.")
            input()
```

## Conclusiones

1. La herencia permite reutilizar código y especializar clases.
2. El sistema demuestra cómo diferentes empleados resuelven tickets según su rol.
3. El menú interactivo en consola integra las funciones principales del sistema.
4. Se aplican clases, herencia, funciones y estructuras de control en un mismo proyecto.